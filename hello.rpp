// omit function body to declare prototypes for external linking, C++ mangle
fn printf(s:str,...)->int;
fn foo(a:*char)->void;

// stolen from rust: function syntax 'fn <function name>(args) optional return value {body}
// however ommitting return value means infer it, not 'void' 

fn something(f:float){
    printf("something overloaded with float param\n");
}

// typeparameter sugar -omitted types get typeparams automatically,
// eg
// template<class A,class B,class F>
//    auto lerp(A a,B b, F f){return (b-a)*f+a;}

fn lerp(a,b,f){(b-a)*f+a};


//  declare a function taking a closure:
//  'funcp' is a variable of function type, 1arg 'int', result 'void'
//  functions declared like this are assumed to be closures
//  represented as a pair of pointers (function*, environment*)
//  raw C like functions are written fn(int)->void


fn take_closure(funcp:(int)->void){
    funcp(10);
}

// struct declarations like Rust.  fieldname:Type,...

struct Foo {
	vx:int, vy:int, vz:int
}

// open overloading like C++; most specific function is matched at callsite
// f:&Foo means parameter 'f' , reference to Foo.. 

fn something_foo(f:&Foo){
    printf("something_foo with 1 arg overloaded\n");
	printf("f.x= %d\n", f.vx);
}
fn something_foo(f:&Foo,x:&Foo){
    printf("something_foo with 2 args overloaded\n");
	printf("f.x= %d,.y= %d,.z= %d\n", f.vx,f.vy,f.vz);
}
fn something(f:&Foo){
    printf("something_foo with 1 arg\n");
	printf("f.x= %d,.y= %d,.z= %d\n", f.vx, f.vy, f.vz);
}
fn something(f:float,x){
    printf("something overloaded with float param & templated param 'x'\n");
    printf("something(float, auto)\n");
}

// [X,Y] = typeparams like scala TODO we might want to accept both
// this isn't a union yet, its just  test to show the type-inference
// can handle getting a 'tag' from methods matching type X or Y
// we may introduce propper tagged unions like Rust, or simply rely on
// better inference & overloading to emulate them with templates?

struct Union[X,Y]{
 tag:int,
 x:X,y:Y,
};

fn setv[X,Y](u:&Union[X,Y],x:Y)->void{
 printf("setv Y\n");
 u.tag=1;
}

// for familiarity. [] read better for nesting but < > are more widespread
fn setv[X,Y](u:&Union[X,Y],x:X)->void{
 printf("setv X\n");
 u.tag=0;
}

fn main(argc:int,argv:**char)->int{
    printf("example program ./hello.rpp compiled & run by default makefile\n");
    // LHS=:RHS initializes empty var with given type Union<int,float> 
    //its a hack till we have let u:Union<int,float>.
    // inspiration from rust is to avoid un-init vars altogether using expression syntax.
    u=:Union[int,float]; 

    // calls to templated functions
    setv(&u,0.0);
    printf("after setting float to u, u.tag= %d\n",u.tag);
    setv(&u,0);
    printf("after setting int to u, u.tag= %d\n",u.tag);
	xs=:array[int,512];   // like C++ array<int,512>
	q:=xs[1]; p1:=&xs[1];
	xs[2]=000;
	xs[2]+=400;
	*p1=30;
	z:=5;
	y:=xs[1]+z+xs[2];
	x:=0;

    // C-like for loops minus parens, compulsory {}
    // handles simple cases without needing a whole iterator library..

	for i:=0,j:=0; i<10; i+=1,j+=10 {
		x+=i;
		printf("i,j=%d,%d,x=%d\n",i,j,x);
	}else{
        // for..else block called if no 'break'
		printf("loop exit fine\n");  
	}
    something_foo(&fv);
	something(&fv);

    // closure syntax stolen from Rust |args,..|{body...}
    take_closure(|x|{printf("closure says %d %d\n",x,y);})

	fv:=Foo{vx=13,vy=14,vz=15}; // initialize struct on stack, named fields
	something_foo(&fv,&fv);

	fv2:=new Foo{vx=23,vy=24,vz=25}; // struct allocate & init
	something_foo(fv2);

	fv3:=new Foo{31,32,33}; // struct initializer, sequential
	something_foo(fv3);

    // Expression syntax stolen from rust.
    // if..else.. has a return value;more flexible than ternary op
    // because it uses compound statements
    // frees up '?' for other use, eg optional types..(TODO arbitrary operators)
    // last expression in the compound blocks is return value from block

	x:=if argc<2{printf("<2");1}else{printf(">2");2};
	printf("yada yada yada\n");
	printf("\nHello World %d\n", y );

    // Stolen from rust: last statement is a return value. 
    // takes some getting used to but makes semicolons significant and
    // interacts very well with expression syntax generally.

	0
}

