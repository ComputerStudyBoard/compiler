LLVM langauge experiment,

a subset of C/C++,+sugar, resyntaxed like Rust.  implemented in C++.

'$ make' to compile & run inbuilt test
'$ ./hack hello.rpp' to compile & run example program.
see 'hello.rpp' example source; 
'hack.cpp' is contains main & bulk of the compiler

I dont have a name yet hence 'hack'..

Currently supports:-

- C operators, functions, structs,if-else, for loops
- Forward+Reverse Type Inference
- stack-based closures
- function overloading
- templates
- limited vtables (base class describes layout, single inheritance)
- emits LLVM sourcecode, compiled by clang, links with C/C++ ecosystem.

Very early days, the compiler is a few weeks old.

Long Term Goals:-

- significant C++ subset resyntaxed
- open-world polymorphism
- add Rust inspired features
- a subset should make a passable embedded dynamic language
- features for parallelism, GPGPU programming

This could all probably be done as a fork of a C++ compiler, or as a fork of Rust. However neither community shares these goals.
this is probably all way beyond a 1man project but I'll see how far I can get..

Goals In detail:-

[1] Resyntax a significant subset of C++, in the spirit of SPECS; 
  - should be possible to non-destructively translate a subset back & forth.
  - context free grammar
  - graph like module import: any file in a project can be the root for its own tests
  - allow use with established C++ libraries & sourcebases
  - could be considered a 'dialect'/'hybrid' rather than a 'language'.
  - add alternate parser that can directly read subset of C++ headers ?
     (or adapt a rust community tool for C++ -> rust translation..)
  - self host by translating own source, be mindful of c++ subset used to write this

[2] Additional Features inspired by Rust & other languages:
 - 2 way inference
 - expression oriented syntax.
 - ADTs (possibly implement as sugar for dynamic_cast<>)
 - optional trait bounds on templates?
 - rust-like trait-objects
 - maybe aim to compile a subset of Rust programs,
   - ... if we can reconcile Rust ideas with C++ semantics
 - maybe aim to transpile Rust aswell? (given our AST will have C++ and Rust-like elements in one place)
 - scala like sugar for default constructor

[3] Additional features..  & inspired by other languages:
 - 100% Open World design - free functions/UFCS/Extention methods
 - minimal syntax changes to rearrange code,
 - adhoc gather of functions into interfaces (like go), or sort by function into switch dispatch
 - use any parameter as 'this'/vtable 
 - possibly multimethods - automate rolling double-dispatch (hence 'any param' as vtable)
 - some sort of reflection, opt in, and compile time.
 - where vtables are used, more flexibility eg hot-swapping, 'static-virtual data', auto roll classfactory& 'message-map'

[4] enhance template engine to replace macro usecases.
 - eg 'ident' parameters, more?
 - functions in the type system to stringify, concat etc.

[5] a subset should make a passable dynamic language
  - whole-program forward inference
  - a single language to handle the C++/embedded Lua usecase. 
  - hence the desire for whole-program inference
    - (recover Rusts old RefCount ptr sigils '@' pointers)
  - maybe want a REPL.
  - statements at root level?

[6] features aimed at parallel,GPGPU/shader programming 
  - eg compile the same code on GPU or CPU for debugging, streamline boilerplate.
  - want intrinsic float4 type with .xyz member swizzle, and half type.
  - GPU&shader programming is important enough to hardcode language features.
  - recover rusts' lost "do" notation for pleasant internal iterators, 
